//******************************************************//*		U R L  T I F F  R E A D E R//*		Class to read Tiff files from a web connection//******************************************************import java.awt.*;import java.awt.image.*;import java.io.*;import java.net.*;class URLTiffReader extends TiffReader{	long	current_read_position = 0;			//******************************************************************	//*			I N I T	//******************************************************************	public URLTiffReader()	{		super();				current_read_position = 0;				return;			}// init	//******************************************************************	//*		G E T  I M A G E	//*		Last modified 7/18/02 for v1.33	//******************************************************************	Image	getImage(URL  url, int slice) throws Exception	{		DataInputStream		is = null;		Image				img = null;		try		{			getFileInfo(url); // get the file info						Settings.image_window.displayMessage("Getting slice " + slice + ".");			is = getImageInputStream(url);			img = getSlice(is, slice); // read in the tiff file			is.close();							if (img != null)			{				Settings.input_file_format = ImageReader.TIFF_FILE;				Settings.output_file_format = ImageReader.TIFF_FILE;			}// if it's a tiff		}		catch (Exception e)		{			if (is != null)				is.close();			throw(e);		}											return(img);			}// end of getImage()	//******************************************************************************	//*		G E T  S L I C E	//*		Skips to the requested image, reads the pixels, and makes the image.	//*			//*		NOTE!!  This method does not do file-size checking the same way it 	//*		would for a file on a local drive.  Files over the web do not always	//*		have all bytes available, so assuming that the number returned by	//*		is.available() is the total file size can result in failure more 	//*		often than not.	//*	//*		Last modified 6/18/02	//******************************************************************************	protected Image  getSlice(DataInputStream is, int slice) throws Exception	{		long		skipped_bytes = 0;		Image		img = null;		int			offset_to_slice = 0;// bytes to skip to get to the slice's data				if (slice <= 0)			slice = 1;					file_size = is.available();					//***** Open the image		if (offset_to_image_data != 0) 		{			offset_to_slice = offset_to_image_data + ((slice - 1) * image_size_in_bytes);							//***** Skip to the start of the image data			skipped_bytes = is.skip((long)offset_to_slice);			if (skipped_bytes != offset_to_slice)				throw (new Exception("Unable to skip to image data."));						}// if there's an offset_to_image_data					switch (Settings.input_file_type) 		{			case GRAY_8_BIT_IMAGE:			case COLOR_8_BIT_IMAGE:				img = read8BitImage(is);				break;			case GRAY_16_BIT_IMAGE:				img = read16BitImage(is);				break;			case GRAY_32_BIT_IMAGE:				img = read32BitImage(is);				break;			case RGB_IMAGE:				img = readRGBImage(is);				break;		}// switch					if (img != null)			Settings.input_file_format = TIFF_FILE;									return(img);			}// end of getSlice()		//******************************************************************	//*			G E T  F I L E  I N F O	//*			Last modified 7/18/02 for v1.33	//******************************************************************	void	 getFileInfo(URL url) throws Exception 	{		DataInputStream		is = null;		int					ifd_offset = 0;									//***** Get offset to image data		is = getImageInputStream(url);		ifd_offset = getIFDOffset(is);		is.close();		if (ifd_offset < 0) 			throw (new Exception("Offset to image data < 0"));			//***** Get the image file directory info		is = getImageInputStream(url);		is.skip(ifd_offset);		current_read_position = ifd_offset;		openIFD(is);		is.close();							//***** Set the IO information		setFileIOInfo();		return;			}// end of getFileInfo()	//**************************************************************************	//*		G E T  I F D  O F F S E T	//*		Open 8-byte file header at start of file.	//*		Returns the offset in bytes to the first IFD 	//*		Last modified 7/16/02 for v1.33	//**************************************************************************	protected int getIFDOffset(DataInputStream is) throws Exception 	{		int byte_order = 0, magic_number = 0;		int	ifd_offset = 0;				byte_order = getShort(is);				if (byte_order == 0x4949) // "II"			this.swap_bytes = true;		else if (byte_order == 0x4d4d) // "MM"			this.swap_bytes = false;		else 		{			is.close();			throw (new Exception("Not a valid TIFF file"));		}				magic_number = getShort(is); // 42		if (magic_number != 42)			throw (new Exception("Not a valid TIFF file"));		ifd_offset = getInt(is); // get the offset				return (ifd_offset);			}// end of getIFDOffset()					//******************************************************************	//*			O P E N  I F D	//*			Last modified 7/15/02 for version 1.33	//******************************************************************	protected void	openIFD (DataInputStream is) throws Exception 	{		// Get Image File Directory data			int 		tag = 0, field_type = 0;		int			count = 0, value = 0;		int 		num_entries = 0, i = 0;		long		skipped_bytes = 0;		long		save_loc = 0;							//***** Get the number of entries		num_entries = getShort(is);				if (num_entries < 1)			throw new Exception("Invalid TIFF header.");				//**** Get each entry			for (i = 0; i < num_entries; i++) 		{			tag = getShort(is);			field_type = getShort(is);			count = getInt(is);			value = getValue(is, field_type, count);						if (tag == 0)				throw new Exception("Invalid TIFF header.");			switch (tag) 			{				case IMAGE_WIDTH: 					Settings.image_width = value;					break;				case IMAGE_LENGTH: 					Settings.image_height = value;					break;				case STRIP_OFFSETS: 					if (count == 1)						offset_to_image_data = value;					else 					{						save_loc = current_read_position;						is.close();						is = getImageInputStream(url);						skipped_bytes = is.skip(value);// go to the offset position						offset_to_image_data = getInt(is); // Assumes contiguous strips						is.close();						is = getImageInputStream(url);						skipped_bytes = is.skip(save_loc); // return to the location where we were						current_read_position = save_loc;					}					break;				case PHOTO_INTERP:					this.zero_is_black = value == 1;					break;				case BITS_PER_SAMPLE:						if (count == 1) 						{							if (value == 8)							{								Settings.input_file_type = GRAY_8_BIT_IMAGE;								Settings.output_file_type = GRAY_8_BIT_IMAGE;								this.bytes_per_pixel = 1;							}							else if (value == 16) 							{								Settings.input_file_type = GRAY_16_BIT_IMAGE;								Settings.output_file_type = GRAY_16_BIT_IMAGE;								this.bytes_per_pixel = 2;							}							else if (value == 32) 							{								Settings.input_file_type = GRAY_32_BIT_IMAGE;								Settings.output_file_type = GRAY_32_BIT_IMAGE;								this.bytes_per_pixel = 4;							}							else								throw new Exception("Unsupported TIFF BitsPerSample: " + value);						}						break;				case SAMPLES_PER_PIXEL:					if (value == 3)					{						Settings.input_file_type = RGB_IMAGE;						Settings.output_file_type = RGB_IMAGE;						this.bytes_per_pixel = 3;					}					else if (value != 1)						throw new Exception("Unsupported TIFF SamplesPerPixel: " + value);					break;				case COMPRESSION: 					if (value !=1 )						throw new Exception("TIFF compression is not supported");				case COLOR_MAP: 					if (count == 768)						getColorMap(is, value);						Settings.input_file_type = COLOR_8_BIT_IMAGE;						this.bytes_per_pixel = 1;					break;				default:			}// switch		}// for each entry					return;			}// end of openIFD	//******************************************************************	//*		G E T  C O L O R  M A P	//*		Last modified 6/13/02	//******************************************************************	void getColorMap(DataInputStream is, int offset_to_image_data) throws Exception 	{		byte[] 		l_color_table;		long 		save_loc = 0;		int			bytes_read = 0;		int			j = 0, i = 0;				l_color_table = new byte[768*2];				//***** Save the current reading position and close the current stream		save_loc = current_read_position; 		is.close();				//***** Make a new stream and read table from correct offset		is = getImageInputStream(url);		is.skip(offset_to_image_data);		bytes_read = is.read(l_color_table);		is.close();				//***** Restore read position to the correct position in a new stream		is = getImageInputStream(url);		is.skip(save_loc);		current_read_position = save_loc;				if (bytes_read != 768*2)			return;					this.color_table = new byte[768];			j = 0;		if (this.swap_bytes)			j++;		for (i = 0; i < 768; i++) 		{			this.color_table[i] = l_color_table[j];			j += 2;		}						return;			}// end of getColorMap	//******************************************************************	//*			G E T  I N T	//******************************************************************	int getInt(DataInputStream is) throws Exception 	{		int 		return_int = 0;				return_int = super.getInt(is);		current_read_position += 4;// advance read position four bytes		return(return_int);				}// end of getInt()	//******************************************************************	//*			G E T  S H O R T	//******************************************************************	int getShort(DataInputStream is) throws Exception 	{		int 		return_int = 0;				return_int = super.getShort(is);		current_read_position += 2;// advance read position two bytes		return(return_int);			}// end of getShort()	}// end of class URLTiffReader