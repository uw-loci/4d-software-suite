import java.awt.*;import java.io.*;import java.net.*;import wvlib.*;class DataDecompressor{	Thread				proc_thread = null;	Thread				update_thread = null;		wv4DBWDecompressor	decompressor = null;	wvFakeDecompressor	fake_decompressor = null;	DataInputStream		in_stream = null;	TiffWriter			tiff_writer = null;	TiffWriter			writer_array[] = null;	int					timepoints_in_block = 0;	int					focalplanes_in_block = 0;	int					num_blocks = 0;	int					image_width = -1, image_height = -1;	int					images_processed = 0;	int					num_decompressions = 0;	boolean				keep_updating = false;	long				total_decompression_time = 0;	long				decompression_start = 0;							//*****************************************************************************************	//*		I N I T	//*		Last modified 11/29/02 for v1.36	//*****************************************************************************************	public DataDecompressor()	{		this.proc_thread = null;		this.update_thread = null;		this.decompressor = null;		this.fake_decompressor = null;		this.in_stream = null;		this.tiff_writer = null;		this.writer_array = null;		this.timepoints_in_block = 0;		this.focalplanes_in_block = 0;		this.num_blocks = 0;		this.image_width = -1;		this.image_height = -1;		this.images_processed = 0;		this.num_decompressions = 0;		this.keep_updating = false;		this.total_decompression_time = 0;		this.decompression_start = 0;						return;			}// init	//*****************************************************************************************	//*		O P E N  B I T  F I L E	//*****************************************************************************************	public void openBitfile() throws CancelledException, Exception	{		FileDialog				fd = null;				fd = new FileDialog(Settings.image_window, "Open first bitfile to decompress.");		fd.setVisible(true);				if (fd.getFile() != null)		{			//**** Based on the filename, setup the defaults			Settings.input_filename = fd.getFile();			Settings.input_directory = fd.getDirectory();			Settings.output_directory = fd.getDirectory();			fd.dispose();		}// if we have a valid file		else			throw new CancelledException();				openBitfile(Settings.input_directory, Settings.input_filename);				return;			}// end of openBitfile()	//*****************************************************************************************	//*		O P E N  B I T  F I L E	//*		Last modified 6/11/02	//*****************************************************************************************	public void openBitfile(String directory, String filename) throws CancelledException, Exception	{				if (directory == null || filename == null)			throw new Exception("Directory or filename was null!");					//**** Based on the filename, setup the defaults		Settings.input_filename = filename;		Settings.input_directory = directory;		Settings.output_directory = directory;		if (!NameUtils.isBitfileName(filename))			throw (new Exception("Bitfile name does not have the proper syntax!"));			//***** Get filename information		Settings.filename_syntax = NameUtils.WAVELET_BITFILE;			Settings.base_bit_filename = NameUtils.findBaseFileName(filename);		Settings.first_bitfile = NameUtils.findSequentialNumber(filename);		Settings.file_extension = NameUtils.findExtension(filename);		Settings.current_bitfile = Settings.first_bitfile;								getInputStream(Settings.first_bitfile);				return;			}// end of openBitfile()	//*****************************************************************************************	//*		O P E N  B I T  F I L E	//*		For use when opening bitfiles from a URL	//*		Last modified 6/21/02	//*****************************************************************************************	public void openBitfile(String filename) throws CancelledException, Exception	{			if (!Settings.use_URL)			throw new Exception("Attempt to open a URL in non-URL mode.");				if (filename == null)			throw new Exception("No filename specified.");					//**** Based on the filename, setup the defaults		Settings.input_filename = filename;		if (!NameUtils.isBitfileName(filename))			throw new Exception("Bitfile name does not have the proper syntax!");			//***** Get filename information		Settings.filename_syntax = NameUtils.WAVELET_BITFILE;			Settings.base_bit_filename = NameUtils.findBaseFileName(filename);		Settings.first_bitfile = NameUtils.findSequentialNumber(filename);		Settings.file_extension = NameUtils.findExtension(filename);		Settings.current_bitfile = Settings.first_bitfile;								getInputStream(Settings.first_bitfile);				return;			}// end of openBitfile()			//*****************************************************************************************	//*		P R O C E S S  D A T A	//*****************************************************************************************	public void processData()	{				//***** Create a runnable object to do the conversion		Runnable do_it = new Runnable()		{			public void run()			{				doProcessing();				}			};				//***** Create a thread for the runnable object to run within		this.proc_thread = new Thread(do_it);				//***** Set its priority low so that the window can update		this.proc_thread.setPriority(Thread.NORM_PRIORITY);//MIN_PRIORITY);				//***** Start the conversion thread running		this.proc_thread.start();	}// end of processData()	//*****************************************************************************************	//*		D O  P R O C E S S I N G	//*		Last modified 1/15/02 for v1.38	//*****************************************************************************************	protected void	 doProcessing()	{		try		{								//***** Get processing info			getUserProcessingInfo();						//***** Make the thread which will update the info panel			createUpdateThread();				//***** Create and/or set the output directory			handleExtractionDirectory();						//***** Loop through and process each bitfile			Settings.image_window.displayMessage("Beginning decompression...");			processBitfiles();											}		catch (OutOfMemoryError ome)		{			handleOutOfMemory();			return;		}		catch (CancelledException ce)		{			handleCancelled();			return;		}		catch (AbortedException ae)		{			handleAborted();			return;		}		catch (Exception e)		{			handleException(e);			return;		}				Settings.image_window.displayMessage("Data set was decompressed successfully!");		resetClassVariables();		return;			}// end of doProcessing()			//*****************************************************************************************	//*		P R O C E S S  B I T F I L E S	//*		Last modified 1/15/03 for v1.38	//*****************************************************************************************	public void processBitfiles() throws AbortedException, Exception	{		Image				decompressed_image = null;		int					timepoint_shift = 1;		int					focalplane_shift = 0;		int					block_num = 0, timepoint = 0, focalplane = 0;						//***** Initialize 		images_processed = 0;		total_decompression_time = 0;		num_decompressions = 0;		Settings.abort = false;				//***** Make sure all the files we're planning to process are present		if (!Settings.use_URL)		{			NameUtils.checkForMissingFiles(Settings.input_directory, Settings.base_bit_filename, 							 	           Settings.filename_syntax, Settings.first_bitfile, Settings.total_bitfiles);		}// if we're working with local files						//***** Each bitfile will have at least one complete timepoint in it		for (int filenum = Settings.first_bitfile; filenum <= Settings.total_bitfiles; filenum++)		{			image_width = -1;			image_height = -1;			focalplane_shift = 0;			timepoints_in_block = 0;							getInputStream(filenum);			getDecompressor();						for (block_num = 0; block_num < num_blocks; block_num++)			{				//***** Decompress the image information from the bitfile										//Settings.image_window.displayMessage("Decompressing block.  Please wait...");					decompression_start = System.currentTimeMillis();				doBlockTransform();				total_decompression_time += System.currentTimeMillis() - decompression_start;				num_decompressions += 1;									//***** Get and display information from the block				getBlockInfo();				//displayBlockInfo();					//***** Create TIFF stacks for the time points, if it's the first block				if (block_num == 0)					writer_array = createTiffStacks(timepoint_shift);									//***** Extract each timepoint in the current block				for (timepoint = 0; timepoint < timepoints_in_block; timepoint++)				{					tiff_writer = writer_array[timepoint];				  					 		//***** Extract each focalplane in the current timepoint	  					for (focalplane = 0; focalplane < focalplanes_in_block; focalplane++)					{						//***** Decompress the image						if (Settings.test_mode)							decompressed_image = fake_decompressor.getImage(focalplane, timepoint);						else							decompressed_image = decompressor.getImage(focalplane, timepoint);						//***** Process the image						if (decompressed_image != null)						{													displayImage(decompressed_image);								//***** Store the image slice to the TIFF stack							tiff_writer.writeImageSlice(decompressed_image);							images_processed += 1;															}// if we have an image														updateInfoPanel(timepoint + timepoint_shift, focalplane + focalplane_shift + 1);						checkForAbort();																					}// for each focalplane in the block																			}// for each timepoint in the block								//***** Increment the focalplane_shift counter				focalplane_shift += focalplanes_in_block;				//***** Save the TIFF stacks to the disk				if (block_num == num_blocks-1)					closeStacks(writer_array, timepoints_in_block);									}// for each block_num										//***** Increment the timepoint_shift counter			timepoint_shift += timepoints_in_block;				} // for each file to decompress			//***** Clean up		keep_updating = false;		image_width = -1;		image_height = -1;						return;			}// end of processBitfiles()	//*****************************************************************************************	//*		G E T  I M A G E  S I Z E	//*****************************************************************************************	private void getImageSize(Image img)	{		do		{			image_width = img.getWidth(null);			image_height = img.getHeight(null);		}		while (image_width == -1 || image_height == -1);				return;			}// end of getImageSize()	//*****************************************************************************************	//*		G E T  U S E R  P R O C E S S I N G  I N F O	//*		Last modified 11/21/02 for v1.36	//*****************************************************************************************	private void getUserProcessingInfo() throws CancelledException, Exception	{		DecompInfoDlog		did = null;		BooleanWrapper		dlog_cancelled = new BooleanWrapper(true);				if (in_stream == null)		{			if (!Settings.use_URL)				openBitfile();			else				openBitfile(Settings.input_filename);		}		getDecompressor();			getOriginalCompSettings();						did = new DecompInfoDlog(Settings.image_window, true, dlog_cancelled);		did.setVisible(true);				//***** See if the user cancelled		if (dlog_cancelled.getValue())			throw new CancelledException();				//***** Check for input validity.  If not valid, try again		if (!userInputValid())		{			IOUtils.putMessage(Settings.image_window, "Illegal value entered!");			getUserProcessingInfo();		}							return;				}// end of getUserProcessingInfo()		//********************************************************************************	//*		U S E R  I N P U T  V A L I D	//*		Runs a series of tests on user input to see if it's invalid	//*		passing this test does NOT insure user input is free of errors.	//*		Added 11/21/02 for v1.36	//********************************************************************************	private boolean userInputValid()	{				if (Settings.output_file_type < 0 && Settings.output_file_type > 1)			return(false);		if (Settings.total_timepoints <= 0)			return(false);		if (Settings.total_planes <= 0)			return(false);		if (Settings.total_bitfiles <= 0)			return(false);		if (Settings.base_timepoint_name == null)			return(false);		if (Settings.output_directory == null)			return(false);				return(true);			}// end of userInputValid()				//*****************************************************************************************	//*		G E T  I N P U T  S T R E A M	//*		Last modifed 1/15/03 for v1.38	//*****************************************************************************************	private void getInputStream(int filenum) throws Exception	{		InputStream			is = null;		DataInputStream		dis = null;		//Settings.image_window.displayMessage("Opening compressed bitfile.  Please wait...");							//***** Get an input stream, and a decompressor object		Settings.input_filename = NameUtils.createBitfileName(Settings.base_bit_filename, filenum);				if (!Settings.use_URL)			in_stream = new DataInputStream(new BufferedInputStream(new FileInputStream(Settings.input_directory + Settings.input_filename)));		else		{			Settings.input_url = new URL(Settings.input_directory_url_string + Settings.input_filename);						is = Settings.input_url.openStream();					if (is != null)			{				dis = new DataInputStream(is);							if (dis != null)					in_stream = dis;			}		}// if we're reading off the web					if (in_stream == null)			throw new Exception("Unable to obtain input stream.");		Settings.status_panel.handleFilename(Settings.input_filename);							return;		}// end of getInputStream()			//*****************************************************************************************	//*		G E T  D E C O M P R E S S O R	//*****************************************************************************************	private void getDecompressor() throws Exception	{		if (Settings.test_mode)		{			fake_decompressor = new wvFakeDecompressor(in_stream);			if (fake_decompressor == null)				throw new Exception("Unable to obtain wvFakeDecompressor");							num_blocks = fake_decompressor.getNumberOfBlocks();		}		else		{			decompressor = new wv4DBWDecompressor(in_stream); 								if (decompressor == null)				throw new Exception("Unable to obtain wv4DBWDecompressor");			num_blocks = decompressor.getNumberOfBlocks();		}				return;			}// end of getDecompressor()		//*****************************************************************************************	//*		G E T  O R I G I N A L  C O M P  S E T T I N G S	//*		Obtains info from the block about the original compression run	//*****************************************************************************************	private void getOriginalCompSettings() throws Exception	{		if (Settings.test_mode)		{			Settings.ocs.base_filename = fake_decompressor.getBasefilename();			Settings.ocs.num_first_timepoint = fake_decompressor.getActualNumberOfFirstTimepoint();			Settings.ocs.num_timepoints_compressed = fake_decompressor.getNumberOfTimepointsCompressed();			Settings.ocs.num_planes_in_stack = fake_decompressor.getNumberOfPlanesInStack();			Settings.ocs.num_bitfiles_created = fake_decompressor.getNumberOfBitfilesCreated();		}		else		{			Settings.ocs.base_filename = decompressor.getBasefilename();			Settings.ocs.num_first_timepoint = decompressor.getActualNumberOfFirstTimepoint();			Settings.ocs.num_timepoints_compressed = decompressor.getNumberOfTimepointsCompressed();			Settings.ocs.num_planes_in_stack = decompressor.getNumberOfPlanesInStack();			Settings.ocs.num_bitfiles_created = decompressor.getNumberOfBitfilesCreated();		}					return;			}// end of getOriginalCompSettings()	//*****************************************************************************************	//*		C R E A T E  U P D A T E  T H R E A D	//*****************************************************************************************	public void createUpdateThread()	{				Settings.start_time = System.currentTimeMillis();			//***** Create a runnable object to do the conversion		Runnable do_it = new Runnable()		{			public void run()			{				doUpdating();				}			};				//***** Create a thread for the runnable object to run within		this.update_thread = new Thread(do_it);				//***** Set its priority		this.update_thread.setPriority(Thread.NORM_PRIORITY);				//***** Start the conversion thread running		this.update_thread.start();	}// end of createUpdateThread()	//********************************************************************************	//*		D O  U P D A T I N G	//********************************************************************************	protected void doUpdating()	{		long	next_update = 0;		String	time_string = null;				keep_updating = true;				try		{					while (keep_updating)			{				Settings.status_panel.handleElapsedTime();				time_string = getTimeRemaining();				Settings.status_panel.handleTimeRemaining(time_string);								try				{					update_thread.sleep(499);				}				catch (InterruptedException ie){}							}// while keep_updating		}		catch (Exception e) 		{			Settings.image_window.displayMessage("Exception in doUpdating()");		}				return;			}// end of doUpdating		//*****************************************************************************************	//*		D O  B L O C K  T R A N S F O R M	//*****************************************************************************************	private void doBlockTransform() throws Exception	{		//***** Get the block and do the inverse transform on it		if (Settings.test_mode)		{			fake_decompressor.readEncoded();			fake_decompressor.doInverseWaveletTransform();		}		else		{			decompressor.readEncoded();			decompressor.doInverseWaveletTransform();		}				return;			}// end of doBlockTransform()		//*****************************************************************************************	//*		G E T  B L O C K  I N F O	//*		Should only be called AFTER doBlockTransform()	//*		Last modified 9/13/02 for v1.34	//*****************************************************************************************	private void getBlockInfo() throws Exception	{		if (Settings.test_mode && fake_decompressor != null)		{			timepoints_in_block = fake_decompressor.getNumberOfTimepointsInEachBlock();			focalplanes_in_block = fake_decompressor.getNumberOfPlanesInCurrentBlock();			image_width = fake_decompressor.getWidth();			image_height = fake_decompressor.getHeight();		}		else if (decompressor != null)		{			timepoints_in_block = decompressor.getNumberOfTimepointsInEachBlock();			focalplanes_in_block = decompressor.getNumberOfPlanesInCurrentBlock();			image_width = decompressor.getWidth();			image_height = decompressor.getHeight();		}		else			throw new Exception("Unable to get block info!");				return;			}// end of getBlockInfo()			//*****************************************************************************************	//*		C R E A T E  T I F F  S T A C K S	//*		Last modified 5/9/02	//*****************************************************************************************	protected TiffWriter[]  createTiffStacks(int timepoint_shift) throws Exception	{		TiffWriter				twa[] = null;		TiffWriter				tw = null;		String					filename = null;		int						i = 0;				twa = new TiffWriter[timepoints_in_block];				for (i = 0; i < timepoints_in_block; i++)		{					//***** Create image filename			filename = NameUtils.createTiffName(Settings.base_timepoint_name, timepoint_shift + i);						//***** Get the TiffWriter			tw = new TiffWriter(filename, image_width, image_height);						//***** Create the stack			tw.createStack(Settings.total_planes);						//***** Add the TiffWriter to the array			if (tw != null)				twa[i] = tw;				}// for each stack to create				//***** Return the array		return(twa);			}// end of createTiffStacks()			//*****************************************************************************************	//*		C L O S E  S T A C K S	//*****************************************************************************************	protected void closeStacks(TiffWriter[] writer_array, int num_stacks) throws Exception	{		TiffWriter		tw = null;		int				i = 0;				for (i = 0; i < num_stacks; i++)		{			tw = writer_array[i];			tw.closeStack();					Settings.image_window.displayMessage("Closing stack " + tw.getFilename() + " with " + tw.getNumSlices() + " slices.");						}				return;			}// end of closeStacks()		//*****************************************************************************************	//*		D I S P L A Y  G R A Y  L E V E L	//*****************************************************************************************	protected void displayGrayLevel(wvFakeDecompressor	decompressor) throws Exception	{		// Show an example of how to determine the number of gray levels:		switch(decompressor.getGrayLevel())		{			case wvGraylevels.GRAY8BIT: 				 Settings.image_window.displayMessage("Reading an 8 bit image");				 break;			case wvGraylevels.GRAY16BIT: 				 Settings.image_window.displayMessage("Reading an 16 bit image");				 break;			case wvGraylevels.GRAY24BIT: 				 Settings.image_window.displayMessage("Reading a 24 bit image");				 break; 				 default: 	  		throw new Exception("Not a supported image bit depth");	  	}// switch	  		  	return;	  		}// end of displayGrayLevel()			//*****************************************************************************************	//*		D I S P L A Y  B L O C K  I N F O	//*****************************************************************************************	protected void displayBlockInfo()	{						Settings.image_window.displayMessage("Timepoints = " + timepoints_in_block);		Settings.image_window.displayMessage("Planes = " + focalplanes_in_block);		Settings.image_window.displayMessage("width = " + image_width);		Settings.image_window.displayMessage("height = " + image_height);				return;			}		//*****************************************************************************************	//*		D I S P L A Y  S T A T U S	//*****************************************************************************************	protected void displayStatus(String bit_name, int filenum, int block_num, int tp, int plane)	{		Settings.image_window.displayMessage("Current filename = " + bit_name);		Settings.image_window.displayMessage("Filenum = " + filenum);		Settings.image_window.displayMessage("Focalplane block = " + block_num);		Settings.image_window.displayMessage("Current tp = " + tp);		Settings.image_window.displayMessage("Current plane = " + plane);				return;			}// end of displayStatus()		//*****************************************************************************************	//*		D I S P L A Y  I M A G E	//*		Last modified 1/8/03 for v1.37	//*****************************************************************************************	protected void displayImage(Image img)	{		try		{			//***** Display the image in the window			if (image_width == -1 || image_height == -1)				getImageSize(img);			Settings.image_canvas.displayImage(img, image_width, image_height);								//try			//{			//	this.proc_thread.sleep(50);// wait for update			//	this.update_thread.sleep(50);// wait for update			//}			//catch (InterruptedException ue){}								}		catch (Exception e)		{			Settings.image_window.displayMessage("Unable to display decompressed image.");		}				return;			}// end of displayImage()		//*****************************************************************************************	//*		H A N D L E  E X C E P T I O N	//*****************************************************************************************	protected void handleException(Exception e)	{		keep_updating = false;		Settings.resetSettings();		Settings.image_window.displayMessage("Exception caught during data decompression.");		Settings.image_window.displayMessage("Data compression was not successful.");		e.printStackTrace();				return;			}// end of handleException	//********************************************************************************	//*		H A N D L E  C A N C E L L E D	//*		Last updated 5/30/02	//********************************************************************************	protected void handleCancelled()	{		Settings.resetSettings();		resetClassVariables();		Settings.image_window.displayMessage("Decompression was cancelled.");				return;			}// end of handleCancelled()	//********************************************************************************	//*		H A N D L E  A B O R T E D	//*		Last updated 6/6/02	//********************************************************************************	protected void handleAborted()	{		Settings.resetSettings();		resetClassVariables();		Settings.image_window.displayMessage("Decompression was aborted.");				return;			}// end of handleAborted()			//********************************************************************************	//*		H A N D L E  O U T  O F  M E M O R Y	//*		Last updated 6/6/02	//********************************************************************************	protected void handleOutOfMemory()	{		Settings.image_window.displayMessage("Out of memory error generated.");		Settings.image_window.displayMessage("Data decompression failed.");		keep_updating = false;		Settings.resetSettings();				return;			}// end of handleOutOfMemory()	//*****************************************************************************************	//*		C H E C K  F O R  A B O R T	//*****************************************************************************************	private void checkForAbort() throws AbortedException	{		if (Settings.abort)		{			Settings.abort = false;			this.keep_updating = false;			throw new AbortedException();		}	}// end of checkForAbort()			//*****************************************************************************************	//*		R E S E T  C L A S S  V A R I A B L E S	//*		Last modified 6/6/02	//*****************************************************************************************	private void resetClassVariables() 	{		decompressor = null;		fake_decompressor = null;		in_stream = null;		tiff_writer = null;		timepoints_in_block = 0;		focalplanes_in_block = 0;		num_blocks = 0;		image_width = 0;		image_height = 0;		keep_updating = false;						return;			}// end of resetClassVariables()	//********************************************************************************	//*		G E T  T I M E  R E M A I N I N G	//********************************************************************************		public String getTimeRemaining()	{		long			delta_ms = 0, total_secs = 0;		long			total_images = 0, remaining_planes = 0;		long			ms_per_slice = 0, remaining_ms = 0;		long			ms_per_decompression = 0;		int				remaining_decompressions = 0;		int				hours = 0, mins = 0, secs = 0;		int				total_mins = 0;		String			time_string = null;				try		{			//***** Determine time per block for decompression (in ms)			if (num_decompressions != 0)				ms_per_decompression = total_decompression_time/num_decompressions;			else				return("??:??:??");						remaining_decompressions = (num_blocks * (Settings.total_bitfiles - Settings.first_bitfile)) - num_decompressions;				//***** Determine average processing time per image (in ms)			total_images = Settings.total_timepoints * Settings.total_planes;			remaining_planes = total_images - this.images_processed;			delta_ms = System.currentTimeMillis() - Settings.start_time;			ms_per_slice = delta_ms/this.images_processed;							//***** Calculate approximate remaining time (in ms)			remaining_ms = (ms_per_slice * remaining_planes) + (ms_per_decompression * remaining_decompressions);			if (remaining_ms < 0)				remaining_ms = 0;							//***** Convert total ms to hours, minutes, and seconds			total_secs = remaining_ms/1000;			total_mins = (int)(total_secs/60);			secs = (int)(total_secs % 60);			hours = (int)(total_mins/60);			mins = (int)(total_mins % 60);					//***** Build the info string			time_string = StringUtils.getTimeString(hours, mins, secs);		}		catch (Exception e)		{			return("??:??:??");		}				return(time_string);			}// end of getTimeRemaining()	//********************************************************************************	//*		U P D A T E  I N F O  P A N E L	//********************************************************************************		private void updateInfoPanel(int cur_timepoint, int cur_focalplane)	{		String		time_string = null;				try		{			Settings.status_panel.handleCurImage(this.images_processed);			Settings.status_panel.handleTotalImages(Settings.total_timepoints * Settings.total_planes);			Settings.status_panel.handleCurTimepoint(cur_timepoint);			Settings.status_panel.handleCurFocalplane(cur_focalplane);			Settings.status_panel.handleFilename(Settings.input_filename);			}		catch (Exception e)		{			Settings.image_window.displayMessage("Exception while updating info panel.");		}				return;	}// end of updateInfoPanel()	//*****************************************************************************************	//*		H A N D L E  E X T R A C T I O N  D I R E C T O R Y	//*		Creates a folder called "Extracted_Files"	//*		Last modified 6/6/02	//*****************************************************************************************	private void  handleExtractionDirectory() throws Exception	{		File		cur_output_directory = null;		File		output_folder = null;		String		output_path = null;		boolean		worked = false;				if (Settings.output_directory == null)			IOUtils.getOutputDirectory();						cur_output_directory = new File(Settings.output_directory);				if (cur_output_directory.exists())		{			output_folder = new File(cur_output_directory.getAbsolutePath() + "Extracted_Files");				// if there's already a folder for extracted files, set the output path to it						if (output_folder.exists()) 			{				output_path = output_folder.getAbsolutePath();				if (!output_path.endsWith(File.separator))					output_path += File.separator;				Settings.output_directory = output_path;				return;			}							worked = output_folder.mkdir();						if (worked)			{				output_path = output_folder.getAbsolutePath();				if (!output_path.endsWith(File.separator))					output_path += File.separator;				Settings.output_directory = output_path;				Settings.image_window.displayMessage("Output folder created.");			}			else				Settings.image_window.displayMessage("Output folder was not created.");		}// if we have a valid output directory		return;		}// end of handleExtractionDirectory()	}// end of class DataDecompressor