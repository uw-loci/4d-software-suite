//******************************************************//*		B I O R A D  R G B  R E A D E R//******************************************************import java.awt.*;import java.awt.image.*;import java.io.*;import java.util.*;class BioradRGBReader extends BioradReader{		public BioradRGBReader()	{		super();				Settings.rgb_settings = new BioradRGBSettings();				return;			}// init		//******************************************************************	//*		G E T  R G B  C H A N N E L  I N F O	//*		Last modified 6/3/02	//******************************************************************	void  getRGBChannelInfo(BooleanWrapper cancelled) throws Exception	{		ChannelsDlog	cd = null;				//*** If it's a 1024 file, find out what channels they want to do		checkForChannels();		cd = new ChannelsDlog((Frame)Settings.image_window, Settings.rgb_settings, cancelled, true);		cd.setVisible(true);				Settings.rgb_settings.got_settings = true;				return;			}// end of getRGBChannelInfo()		//******************************************************************************	//*		G E T  I M A G E	//*		Returns a single slice of a Biorad 1024 file as a java.awt.Image 	//*		Last modified 6/11/02 for version 1.33	//******************************************************************************	Image	getImage(String input_directory, String filename, int slice) throws CancelledException, Exception	{		Image						img = null;		DataInputStream				red_is = null;		DataInputStream				green_is = null;		DataInputStream				blue_is = null;		String						red_filename = null;		String						green_filename = null;		String						blue_filename = null;		int							timepoint_number = 0;		BooleanWrapper				cancelled = new BooleanWrapper(false);			Settings.input_file_type = ImageReader.RGB_IMAGE;				timepoint_number = NameUtils.findSequentialNumber(filename);				if (!Settings.rgb_settings.got_settings)			getRGBChannelInfo(cancelled);					if (cancelled.getValue())			throw new CancelledException();					//***** Get the filenames for the active channels		if (Settings.rgb_settings.ch_1_on)		{			red_filename = NameUtils.createBioradRGBName(Settings.base_timepoint_name, timepoint_number, 1);			Settings.input_filename = new String(red_filename);		}		if (Settings.rgb_settings.ch_2_on)		{			green_filename = NameUtils.createBioradRGBName(Settings.base_timepoint_name, timepoint_number, 2);			Settings.input_filename = new String(green_filename);		}		if (Settings.rgb_settings.ch_3_on)		{			blue_filename = NameUtils.createBioradRGBName(Settings.base_timepoint_name, timepoint_number, 3);			Settings.input_filename = new String(blue_filename);		}			getFileInfo(input_directory, Settings.input_filename);				//***** Get the InputStreams for the active channels		if (Settings.rgb_settings.ch_1_on)			red_is = getImageInputStream(input_directory, red_filename);		if (Settings.rgb_settings.ch_2_on)			green_is = getImageInputStream(input_directory, green_filename);		if (Settings.rgb_settings.ch_3_on)			blue_is = getImageInputStream(input_directory, blue_filename);				//***** Read the RGB Image		img = getSlice(red_is, green_is, blue_is, slice);					//**** Close the InputStreams		if (red_is != null)			red_is.close();		if (green_is != null)			green_is.close();		if (blue_is != null)			blue_is.close();							return(img);			}// end of getImage()	//******************************************************************************	//*		G E T  S L I C E	//*		Assumes you have not skipped any bytes.  Skips to the beginning of the	//*		slice data, and reads one slice (image_width * image_height * bytes_per_pixel) in size	//******************************************************************************	Image	getSlice(DataInputStream red_is, DataInputStream green_is, DataInputStream blue_is, 					 int slice) throws Exception	{		long		skipped_bytes = 0;		Image		img = null;		int			offset_to_slice = 0;// bytes to skip to get to the slice's data		int			img_size = 0;		int[]		pixels = null;				try 		{			if (slice <= 0)				slice = 1;						img_size = Settings.image_width * Settings.image_height;						if (Settings.rgb_settings.ch_1_on)			{					file_size = red_is.available();							offset_to_slice = 76 + ((slice - 1) * img_size);								if (file_size < (offset_to_slice + img_size)) 					throw (new Exception("Slice not available in image file."));				//***** Skip to the start of the image data				skipped_bytes = red_is.skip((long)offset_to_slice);				if (skipped_bytes != offset_to_slice)					throw (new Exception("Cannot skip to image data."));									file_size = (int)(file_size - skipped_bytes);			}// red channel				if (Settings.rgb_settings.ch_2_on)			{					file_size = green_is.available();							offset_to_slice = 76 + ((slice - 1) * img_size);								if (file_size < (offset_to_slice + img_size)) 					throw (new Exception("Slice not available in image file."));				//***** Skip to the start of the image data				skipped_bytes = green_is.skip((long)offset_to_slice);				if (skipped_bytes != offset_to_slice)					throw (new Exception("Cannot skip to image data."));									file_size = (int)(file_size - skipped_bytes);			}//green channel			if (Settings.rgb_settings.ch_3_on)			{					file_size = blue_is.available();							offset_to_slice = 76 + ((slice - 1) * img_size);								if (file_size < (offset_to_slice + img_size)) 					throw (new Exception("Slice not available in image file."));				//***** Skip to the start of the image data				skipped_bytes = blue_is.skip((long)offset_to_slice);				if (skipped_bytes != offset_to_slice)					throw (new Exception("Cannot skip to image data."));									file_size = (int)(file_size - skipped_bytes);			}//green channel									pixels = getImagePixels(red_is, green_is, blue_is);	   			img = Toolkit.getDefaultToolkit().createImage(new MemoryImageSource(Settings.image_width, Settings.image_height, pixels, 0, Settings.image_width));		  			if (img != null)			{				Settings.input_file_format = ImageReader.BIORAD_1024_FILE;				Settings.output_file_type = ImageReader.RGB_IMAGE;			}													}// try				catch (Exception e) 		{			throw (e); // rethrow the exception		}// catch				return(img);			}// end of getRGBImage()	//******************************************************************************	//*		G E T  I M A G E  P I X E L S	//*		Reads a pixel from each channel that's active	//*		then composites them into a 24-bit RGB image	//*		Assumes you've alredy skipped to the beginning of the image data	//*		in each DataInputStream	//*	//*		Last modified 7/10/02	//******************************************************************************	int[]  getImagePixels(DataInputStream red_is, DataInputStream green_is, DataInputStream blue_is) throws Exception 	{			long			fs = 0, img_size = 0;		int				pixels_read = 0;		Image			img = null;		byte[] 			red_buffer = null, green_buffer = null, blue_buffer = null;		int[]			pixels;		int 			r = 0, g = 0, b = 0;		int 			bytes_read = 0;		int				red_bytes_read = 0, green_bytes_read = 0, blue_bytes_read = 0;		int 			total_bytes_read = 0, bytes_to_read = 0;		int 			base = 0, i = 0, j = 0;						if (green_is != null)			fs = green_is.available();		else if (red_is != null)			fs = red_is.available();		else if (blue_is != null)			fs = blue_is.available();															img_size = Settings.image_width * Settings.image_height; // size of one image in bytes					if (fs < img_size) 				throw (new Exception("Slice not available in image file."));		//***** Make the buffers to hold the byte and pixel information				buffer_size = (Settings.image_width * Settings.image_height)/25;		if (buffer_size < 8192)			buffer_size = 8192;		else			buffer_size = (buffer_size/8192)*8192;					if (Settings.rgb_settings.ch_1_on)			red_buffer = new byte[buffer_size];		if (Settings.rgb_settings.ch_2_on)			green_buffer = new byte[buffer_size];		if (Settings.rgb_settings.ch_3_on)			blue_buffer = new byte[buffer_size];					pixels = new int[Settings.image_width * Settings.image_height];					bytes_to_read = Settings.image_width * Settings.image_height;									while (total_bytes_read < bytes_to_read) 		{			//***** Adjust buffer size to appropriate size			if (buffer_size > (bytes_to_read - total_bytes_read))				buffer_size = (bytes_to_read - total_bytes_read);								//**** Read in a 24 line chunk			if (Settings.rgb_settings.ch_1_on && red_buffer != null)			{				red_bytes_read = red_is.read(red_buffer, 0, buffer_size);				if (red_bytes_read == -1)					throw new Exception();				bytes_read = red_bytes_read;			}			if (Settings.rgb_settings.ch_2_on && green_buffer != null)			{				green_bytes_read = green_is.read(green_buffer, 0, buffer_size);				if (green_bytes_read == -1)					throw new Exception();				bytes_read = green_bytes_read;			}			if (Settings.rgb_settings.ch_3_on && blue_buffer != null)			{				blue_bytes_read = blue_is.read(blue_buffer, 0, buffer_size);				if (blue_bytes_read == -1)					throw new Exception();				bytes_read = blue_bytes_read;			}							total_bytes_read += bytes_read;			pixels_read = bytes_read;			if ((base + pixels_read) > (Settings.image_width * Settings.image_height))				pixels_read = (Settings.image_width * Settings.image_height) - base;								for (i = base, j = 0; i < (base + pixels_read); i++, j++) 			{				if (Settings.rgb_settings.ch_1_on)					r =  red_buffer[j] & 0xff;				else					r = 0 & 0xff;				if (Settings.rgb_settings.ch_2_on)					g = green_buffer[j] & 0xff;				else					g = 0 & 0xff;				if (Settings.rgb_settings.ch_3_on)					b = blue_buffer[j] & 0xff;				else					b = 0 & 0xff;														pixels[i] = 0xff000000 | (r << 16) | (g << 8) | b;								}// for each byte in the buffer								base += pixels_read;		}// while the entire file hasn't been read       		return(pixels);        	}// end of getRGBImagePixels()		//*************************************************************************	//*		C H E C K  F O R   C H A N N E L S	//*		Given a Biorad 1024 filename, checks the directory	//*		for filenames corresponding to channels 1, 2 & 3	//*		Last modified 7/11/02	//*************************************************************************	void	checkForChannels() throws Exception	{		File		test_file = null;		String		test_name = null;		int			num_channels = 0;				// Check for the red channel		test_name = NameUtils.createBioradRGBName(Settings.base_timepoint_name, Settings.first_timepoint, 1);		test_file = new File(Settings.input_directory + test_name);		Settings.rgb_settings.ch_1_on = test_file.exists();		// Check for the green channel		test_name = NameUtils.createBioradRGBName(Settings.base_timepoint_name, Settings.first_timepoint, 2);		test_file = new File(Settings.input_directory + test_name);		Settings.rgb_settings.ch_2_on = test_file.exists();		// Check for the blue channel		test_name = NameUtils.createBioradRGBName(Settings.base_timepoint_name, Settings.first_timepoint, 3);		test_file = new File(Settings.input_directory + test_name);		Settings.rgb_settings.ch_3_on = test_file.exists();					if (Settings.rgb_settings.ch_1_on)			num_channels += 1;		if (Settings.rgb_settings.ch_2_on)			num_channels += 1;		if (Settings.rgb_settings.ch_3_on)			num_channels += 1;						Settings.rgb_settings.num_channels = num_channels;				return;			}// end of checkForChannels()/*	//*************************************************************************	//*		G E T   C H A N N E L  N U M B E R	//*		Returns the channel number given the filename of a 1024 file	//*************************************************************************	static int get1024ChannelNumber(String fn)	{		int			channel = NOT_FOUND;		int			num_chars = 0, i = 0;		int			dot_position = NOT_FOUND;		String		channel_str = new String();		char[]		char_array;				//**** Find number of characters		num_chars = fn.length();				//***** Find the dot		for (i = 0; i < fn.length(); i++)		{			if (fn.charAt(i) == '.')			{				dot_position = i;				break;			}		}				if (dot_position == NOT_FOUND)			return(channel);					//***** Get the string representing the channel		char_array = new char[2];		char_array[0] = fn.charAt(dot_position - 2);		char_array[1] = fn.charAt(dot_position - 1);		channel_str = new String(char_array);		channel = ImageReader.getInt(channel_str);		switch (channel)		{			case 1:				  Settings.rgb_settings.ch_1_on = true;				  break;			case 2:				  Settings.rgb_settings.ch_2_on = true;				  break;			case 3: 				  Settings.rgb_settings.ch_3_on = true;				  break;		}// end switch							return(channel);					}// end of get1024ChannelNumber()	*/	}//end of class BioradRGBReader