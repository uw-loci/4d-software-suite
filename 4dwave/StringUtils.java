import java.awt.*;class StringUtils {	//*************************************************************************	//*		I N T  F R O M  S T R I N G	//*		Last modified 7/17/02 for v1.33	//*************************************************************************	static  int  intFromString(String num_string) throws Exception	{		Double		d = null;		int			int_value = 0;				d = new Double(num_string);		int_value = d.intValue();			return (int_value);			}// end of intFromString()	//********************************************************************	//*		N U M  T O  S T R I N G	//********************************************************************	static String	numToString (long	number, int  places)	{		int			count = 0, number_chars = 1;		long		temp_number = 0;		boolean		negative_number = false;		int			i = 0, j = 0;		int			zeros_to_pad = 0;		String		raw_num_string;		String		num_string = new String("");		char[]		char_array;				//***** Convert number to positive, if necesssary		if (number < 0)		{				negative_number = true;			number = -number;		}			temp_number = number;		//***** find out number of characters in the number		for (count = 0; temp_number >= 10; count++)		{			temp_number = temp_number/10;			number_chars += 1;		}			//***** Find out how many zeros we're going to pad		if (places <= 1)			zeros_to_pad = 0;		else			zeros_to_pad = places - number_chars;				temp_number = number;			char_array = new char[number_chars];			// ***** convert number to a byte_array		for (count = (number_chars-1); count >= 0; count--)		{			char_array[count] = (char)((temp_number % 10) + 48);			temp_number = temp_number / 10;			}		//***** Convert char array to string		raw_num_string = new String(char_array);				//***** Add the - if necessary		if (negative_number)			num_string += '-';					//***** Finally, pad out the zeros, if necessary		for (i = 0; i < zeros_to_pad; i++)		{			num_string += '0';		}// for each zero to pad out			num_string += raw_num_string;				return(num_string);		} // end of numToString()	static String  getTimeString(int hours, int mins, int secs) throws Exception	{		String			t_string = null;		StringBuffer	string_buffer = new StringBuffer(16);			if (hours < 10)			string_buffer.append('0');		string_buffer.append(hours);		string_buffer.append(':');		if (mins < 10)			string_buffer.append('0');		string_buffer.append(mins);		string_buffer.append(':');		if (secs < 10)			string_buffer.append('0');		string_buffer.append(secs);				t_string = new String(string_buffer);		string_buffer = null;				return(t_string);		}// end of getTimeString()		//**************************************************************************************	//*		G E T  S I Z E D  F O N T	//*			//*		Returns a font that is the largest font that is less than text_field_height	//*		This is a utility for sizing text to fit into TextField objects.	//*		The default font that will be returned is Dialog Plain 12 point.	//**************************************************************************************	static Font  getSizedFont(String font_name, int font_style, int text_field_height, int max_font_size)	{		Font			return_font = new Font("Dialog", Font.PLAIN, 12);		Font			test_font = null;		FontMetrics		fm = null;		int				char_height, font_size = 5, i = 0;				try		{			for (i = 0; i < 50; i++)			{				test_font = new Font(font_name, font_style, font_size + i);								if (test_font != null)				{					fm = Toolkit.getDefaultToolkit().getFontMetrics(test_font);					char_height = fm.getHeight();									if ((char_height > text_field_height) || (font_size + i > max_font_size))					{						if (i > 0)							return(return_font);						break;					}									return_font = test_font;								}// if we have a font					}// step through the font sizes							return(return_font);		}// try		catch (Exception e)		{			return(return_font);		}	}// end of getSizedFont()	//**************************************************************************************	//*		G E T  M A X  C H A R A C T E R S	//*			//*		Given the parameters which define a font, this method returns the number 	//*		of characters which will fit into a TextField of field_width pixels.	//*		This is a utility for sizing text to fit into TextField objects.	//*		If an exception is throw, the method will return -1.	//**************************************************************************************	static int  getMaxCharacters(String font_name, int font_style, int font_size, int text_field_width)	{		Font			test_font = null;		FontMetrics		fm = null;		int				char_width = -1, i = 1, max_characters = -1;				try		{			test_font = new Font(font_name, font_style, font_size);			fm = Toolkit.getDefaultToolkit().getFontMetrics(test_font);			char_width = fm.charWidth('a');				if (char_width < 1)				return(-1);							for (i = 1; i< Integer.MAX_VALUE; i++)			{								if (i * char_width > text_field_width)					break;								max_characters = i;													}// increment the number of characters						return(max_characters);							}// try		catch (Exception e)		{			return(-1);		}	}// end of getMaxCharacters()	//**************************************************************************************	//*		T R U N C A T E  S T R I N G	//*	//*		Given a string, this method will return a string which has been shortened to 	//*		num_characters in length.  The characters "..." will be inserted in the middle 	//*		of the string and as many characters from the front and end of the string 	//*		as will fit will be used.  The number of characters used from each end	//*		of the string will be roughly equal.	//**************************************************************************************	static String truncateString(String source_string, int num_characters) throws Exception	{		String	return_string = null;		int		string_length = 0;		int		pre_chars = 0, post_chars = 0;				if (source_string == null)			throw new Exception("Unable to truncate string.  String is null.");					if (num_characters < 4)			throw new Exception("Number of characters must be > 4 to truncate string.");					if (source_string.length() <= num_characters)		{			return_string = new String(source_string);		}// if the string doesn't need to be trimmed		else		{			pre_chars = post_chars = (num_characters - 3)/2;			return_string = source_string.substring(0, pre_chars);			return_string += "...";			return_string += source_string.substring(source_string.length() - post_chars);				}// if the string needs to be trimmed				return(return_string);			}// end of truncateString	//**************************************************************************************	//*		F I T  S T R I N G  T O  W I D T H	//*			//*		Given a font, this method returns a string that is less than width pixels by	//*		iterating through truncateString until the string fits.	//*		This is a utility for sizing text to fit into TextField objects.	//**************************************************************************************	static String  fitStringToWidth(String source_string, Font f, int width)	{		FontMetrics		fm = null;		String			return_string = null;		int				string_width = -1, i = 1;				try		{			fm = Toolkit.getDefaultToolkit().getFontMetrics(f);								for (i = 0; i< source_string.length(); i++)			{				if (source_string.length() - i < 1)					break;													return_string = truncateString(source_string, source_string.length() - i);				string_width = fm.stringWidth(return_string);								if (string_width < width)					return(return_string);										}// decrement the number of characters						return(return_string);										}// try		catch (Exception e)		{			return(source_string);		}	}// end of getMaxCharacters()		}// end of class StringUtils