//******************************************************//*		T I F F  R E A D E R//******************************************************//Some code modified from Wayne Rasband's freeware application "NIH-Image/J"import java.awt.*;import java.awt.image.*;import java.io.*;import java.util.*;class TiffReader extends ImageReader{	//***** TIFF HEADER CONSTANTS	final		static	int			NEW_SUBFILE_TYPE = 254;	final		static	int			IMAGE_WIDTH = 256;	final		static	int			IMAGE_LENGTH = 257;	final		static	int			BITS_PER_SAMPLE = 258;	final		static	int			COMPRESSION = 259;	final		static	int			PHOTO_INTERP = 262;	final		static	int			STRIP_OFFSETS = 273;	final		static	int			SAMPLES_PER_PIXEL = 277;	final		static	int			ROWS_PER_STRIP = 278;	final		static	int			STRIP_BYTE_COUNT = 279;	final		static	int			X_RESOLUTION = 282;	final		static	int			Y_RESOLUTION = 283;	final		static	int			PLANAR_CONFIGURATION = 284;	final		static	int			RESOLUTION_UNIT = 296;	final		static	int			COLOR_MAP = 320;	final		static	int			IMAGE_HDR = -22222; //43314		public TiffReader()	{		super();				return;			}// init		//******************************************************************	//*			G E T  I M A G E	//******************************************************************	Image	getImage(String input_directory, String filename, int slice) throws Exception	{		Image				img = null;		DataInputStream		is = null;		try		{			is = getImageInputStream(input_directory, filename); //open the file			if (is != null)			{				//***** Try opening as a tiff				getFileInfo(input_directory, filename); // get the file info				img = getSlice(is, slice); // read in the tiff file				is.close();				if (img != null)				{					Settings.input_file_format = ImageReader.TIFF_FILE;					Settings.output_file_format = ImageReader.TIFF_FILE;				}// if it's a tiff							}// if the info stream is available		}// try		catch (Exception e)		{			is.close();			throw(e);		}				return(img);			}// end of getImage()	//******************************************************************************	//*		G E T  S L I C E	//*		Skips to the requested image and reads it	//******************************************************************************	protected Image  getSlice(DataInputStream is, int slice) throws Exception	{		long		skipped_bytes = 0;		Image		img = null;		int			offset_to_slice = 0;// bytes to skip to get to the slice's data				try 		{			if (slice <= 0)				slice = 1;							file_size = is.available();						//***** Open the image			if (offset_to_image_data != 0) 			{				offset_to_slice = offset_to_image_data + ((slice - 1) * image_size_in_bytes);								if (file_size < (offset_to_image_data + image_size_in_bytes)) 					throw (new Exception("Slice not available in image file."));				//***** Skip to the start of the image data				skipped_bytes = is.skip((long)offset_to_slice);				if (skipped_bytes != offset_to_slice)					throw (new Exception("Cannot skip to image data."));									file_size = (int)(file_size - skipped_bytes);			}// if there's an offset_to_image_data						switch (Settings.input_file_type) 			{				case GRAY_8_BIT_IMAGE:				case COLOR_8_BIT_IMAGE:					img = read8BitImage(is);					break;				case GRAY_16_BIT_IMAGE:					img = read16BitImage(is);					break;				case GRAY_32_BIT_IMAGE:					img = read32BitImage(is);					break;				case RGB_IMAGE:					img = readRGBImage(is);					break;			}// switch						if (img != null)				Settings.input_file_format = TIFF_FILE;							}// try				catch (Exception e) 		{			throw (e); // rethrow the exception		}// catch				return(img);			}// end of getSlice()	//******************************************************************	//*			G E T  F I L E  I N F O	//*			Last modified 6/11/02	//******************************************************************	void	 getFileInfo(String directory, String filename) throws Exception 	{		DataInputStream					is = null;		int 							ifd_offset = 0;		RandomAccessFile				raf = null;		File							f = null;											f = new File(directory + filename);		raf = new RandomAccessFile(f, "r");					//***** Get offset to image data		ifd_offset = getIFDOffset(raf);		if (ifd_offset < 0) 		{			raf.close();			throw (new Exception("IFD offset < 0"));		}			//***** Get the image file directory info		raf.seek(ifd_offset);		openIFD(raf);		raf.close();				//**** Get the number of slices		is = new DataInputStream(new BufferedInputStream(new FileInputStream(directory + filename)));		Settings.total_planes = getNumSlices(is);					//***** Set the IO information		setFileIOInfo();		return;			}// end of getFileInfo()	//******************************************************************************	//*		G E T  N E X T  S L I C E	//******************************************************************************	protected Image  getNextSlice(DataInputStream is) throws Exception	{		Image		img = null;				try 		{			file_size = is.available();						if (file_size < image_size_in_bytes) 					throw (new Exception("Slice not available in image file."));						switch (Settings.input_file_type) 			{				case GRAY_8_BIT_IMAGE:				case COLOR_8_BIT_IMAGE:					img = read8BitImage(is);					break;				case GRAY_16_BIT_IMAGE:					img = read16BitImage(is);					break;				case GRAY_32_BIT_IMAGE:					img = read32BitImage(is);					break;				case RGB_IMAGE:					img = readRGBImage(is);					break;			}// switch						if (img != null)				Settings.input_file_format = TIFF_FILE;							}// try				catch (Exception e) 		{			throw (e); // rethrow the exception		}// catch				return(img);			}// end of getNextSlice()		//**************************************************************************	//*		G E T  I F D  O F F S E T	//*		Open 8-byte file header at start of file.	//*		Returns the offset in bytes to the first IFD 	//*		Last modified 7/16/02 for v1.33 	//**************************************************************************	protected int getIFDOffset(RandomAccessFile raf) throws Exception 	{		int byte_order = 0, magic_number = 0;		int	ifd_offset = 0;				byte_order = getShort(raf);				if (byte_order==0x4949) // "II"			this.swap_bytes = true;		else if (byte_order==0x4d4d) // "MM"			this.swap_bytes = false;		else 		{			raf.close();			throw (new Exception("Not a valid TIFF file"));		}				magic_number = getShort(raf); // 42		if (magic_number != 42)			throw (new Exception("Not a valid TIFF file"));		ifd_offset = getInt(raf); // get the offset				return (ifd_offset);			}// end of getIFDOffset()	//******************************************************************	//*			O P E N  I F D	//******************************************************************	protected void	openIFD (RandomAccessFile raf) throws Exception 	{		// Get Image File Directory data			int 		tag = 0, field_type = 0;		int			count = 0, value = 0;		int 		num_entries = 0, i = 0;		long		save_loc = 0;				//***** Get the number of entries		num_entries = getShort(raf);				if (num_entries < 1)			throw new Exception("Invalid TIFF header.");				//**** Get each entry			for (i = 0; i < num_entries; i++) 		{			tag = getShort(raf);			field_type = getShort(raf);			count = getInt(raf);			value = getValue(raf, field_type, count);						if (tag == 0)				throw new Exception("Invalid TIFF header.");			switch (tag) 			{				case IMAGE_WIDTH: 					Settings.image_width = value;					break;				case IMAGE_LENGTH: 					Settings.image_height = value;					break;				case STRIP_OFFSETS: 					if (count == 1)						offset_to_image_data = value;					else 					{						save_loc = raf.getFilePointer();						raf.seek(value);						offset_to_image_data = getInt(raf); // Assumes contiguous strips						raf.seek(save_loc); // return to the saved location					}					break;				case PHOTO_INTERP:					this.zero_is_black = value == 1;					break;				case BITS_PER_SAMPLE:						if (count == 1) 						{							if (value == 8)							{								Settings.input_file_type = GRAY_8_BIT_IMAGE;								Settings.output_file_type = GRAY_8_BIT_IMAGE;								this.bytes_per_pixel = 1;							}							else if (value == 16) 							{								Settings.input_file_type = GRAY_16_BIT_IMAGE;								Settings.output_file_type = GRAY_16_BIT_IMAGE;								this.bytes_per_pixel = 2;							}							else if (value == 32) 							{								Settings.input_file_type = GRAY_32_BIT_IMAGE;								Settings.output_file_type = GRAY_32_BIT_IMAGE;								this.bytes_per_pixel = 4;							}							else								throw new Exception("Unsupported TIFF BitsPerSample: " + value);						}						break;				case SAMPLES_PER_PIXEL:					if (value == 3)					{						Settings.input_file_type = RGB_IMAGE;						Settings.output_file_type = RGB_IMAGE;						this.bytes_per_pixel = 3;					}					else if (value != 1)						throw new Exception("Unsupported TIFF SamplesPerPixel: " + value);					break;				case COMPRESSION: 					if (value !=1 )						throw new Exception("TIFF compression is not supported");				case COLOR_MAP: 					if (count == 768)						getColorMap(raf, value);						Settings.input_file_type = COLOR_8_BIT_IMAGE;						this.bytes_per_pixel = 1;					break;				default:			}// switch		}// for each entry					return;			}// end of openIFD	//******************************************************************************	//*		G E T  N U M  S L I C E S	//*		Takes the image stream, subtracts the header size	//*		and determines the number of slices available	//*			//*		Last modified 6/12/02	//******************************************************************************	protected int	getNumSlices(DataInputStream is) throws Exception	{		int					is_size = 0;		int					n_slices = 0;		int					off = this.offset_to_image_data;		int					img_size = 0;							img_size = Settings.image_width * Settings.image_height * this.bytes_per_pixel;		if (img_size == 0)			return(0);		is_size = is.available();// get the size of the file in bytes		is_size -= offset_to_image_data;// subtract the size of header		n_slices = is_size/img_size;// get num slices		is.close();				return(n_slices);				}// end of getNumSlices()	//******************************************************************	//*			G E T  C O L O R  M A P	//******************************************************************	void getColorMap(RandomAccessFile raf, int offset_to_image_data) throws Exception 	{		byte[] 		l_color_table;		long 		save_loc = 0;		int			bytes_read = 0;		int			j = 0, i = 0;				l_color_table = new byte[768*2];		save_loc = raf.getFilePointer();				raf.seek(offset_to_image_data);		bytes_read = raf.read(l_color_table);		raf.seek(save_loc);		if (bytes_read != 768*2)			return;					this.color_table = new byte[768];			j = 0;		if (this.swap_bytes)			j++;		for (i = 0; i < 768; i++) 		{			this.color_table[i] = l_color_table[j];			j += 2;		}						return;			}// end of getColorMap	}// end of class TiffReader