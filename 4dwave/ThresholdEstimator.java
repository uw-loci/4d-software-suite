import java.awt.*;import java.io.*;import wvlib.*;class ThresholdEstimator extends DataCompressor{	wvFindThreshold			estimator = null;		wvThresholdAndValue		last_value = null;	boolean					waiting_for_threshold = false;	//********************************************************************************	//*		I N I T	//********************************************************************************	public ThresholdEstimator(ImageReader iih)	{		super(iih);				this.estimator = null;				return;		}// init	//********************************************************************************	//*		D O  P R O C E S S I N G	//********************************************************************************	public void processData()	{				//***** Create a runnable object to do the estimation			Runnable do_it = new Runnable()		{			public void run()			{				doProcessing();			}			};				//***** Create a thread for the runnable object to run within		proc_thread = new Thread(do_it);				//***** Set its priority		proc_thread.setPriority(Thread.NORM_PRIORITY);				//***** Start the conversion thread running		proc_thread.start();	}// end of processData()	//********************************************************************************	//*		D O  P R O C E S S I N G	//*		Last modified 1/15/03 for v1.38	//********************************************************************************	protected void doProcessing()	{		Image			cur_image = null;						try		{									//***** Open the first timepoint				cur_image = image_reader.getImage(Settings.input_directory, Settings.input_filename, 1);						//***** Get processing info			getUserProcessingInfo();				//***** Display the image in the window			displayImage(cur_image);			createUpdateThread();						//***** Loop through and process each timepoint			Settings.image_window.displayMessage("Beginning threshold estimation...");			processTimepoints();			//***** Get our threshold value			waiting_for_threshold = true;			calculateThreshold();					//***** Pause this thread to allow calculation to occur			while(waiting_for_threshold)			{				try				{					checkForAbort();					proc_thread.sleep(500);				}				catch (InterruptedException ie){}			}						Settings.image_window.displayMessage("End of threshold estimation procedure.");			resetClassVariables();		}		catch (OutOfMemoryError ome)		{			handleOutOfMemory();			return;		}		catch (CancelledException e)		{			handleCancelled();			return;		}		catch (AbortedException ae)		{			handleAborted();			return;		}		catch (Exception e)		{			handleException(e);			return;		}				return;			}// end of doProcessing()		//****************************************************************************************************************	//*		P R O C E S S  T I M E P O I N T S	//*		Last modified 6/6/02	//****************************************************************************************************************	public void processTimepoints() throws AbortedException, Exception	{		wvThresholdAndValue		threshold_value = null;		String					movie_filename = null, timepoint_filename = null;		Image					cur_image = null;		boolean 				block_size_set = false;		int						plane = 0, tp = 0;		int						time = 0, space = 0;						//***** Get info and output settings		image_width = -1;		image_height = -1;		Settings.abort = false;		getNumTimepointBlocks();		getNumFocalplaneBlocks();		displaySettings(num_timepoint_blocks, num_focalplane_blocks);		//***** Make sure all the files we're planning to process are present		NameUtils.checkForMissingFiles(Settings.input_directory, Settings.base_timepoint_name, 							 	       Settings.filename_syntax, Settings.first_timepoint, Settings.total_timepoints);							for (tp = Settings.first_timepoint, time = 0; time < CompressionSettings.timepoints_per_block; tp++, time++)		{			timepoint_filename = NameUtils.createInputFilename(Settings.base_timepoint_name, tp, Settings.filename_syntax, 0);							//**** Update settings			Settings.input_filename = new String(timepoint_filename);			//***** Process each plane			for (plane = Settings.first_plane, space = 0; space < CompressionSettings.focalplanes_per_block; plane++, space++)			{				//***** Get the individual slice				cur_image = image_reader.getImage(Settings.input_directory, timepoint_filename, plane);	     		     		if (image_width == -1 || image_height == -1)	    			getImageSize(cur_image);	      				//***** Display the image in the window				displayImage(cur_image);					      			      		//***** Get an estimator, if we don't have one already		      		if (estimator == null)	      			getEstimator();	      								estimator.setImage(cur_image, space, time);										cur_image = null;				images_processed += 1;										//***** Update the information in the info panel				updateInfoPanel(tp, plane);				checkForAbort();									}// for each focal plane in a space block					}// for each timepoint in a time block	  		  					  				  								return;	}// end of processTimepoints()	//********************************************************************************	//*		G E T  U S E R  P R O C E S S I N G  I N F O	//*		Last modified 1/7/03 for v1.37	//********************************************************************************	private void getUserProcessingInfo() throws CancelledException, Exception	{		ThreshEstDlog		ted = null;		BooleanWrapper		cancelled = new BooleanWrapper(false);				//***** Set last timepoint default to be the number of files in the directory			Settings.last_timepoint = Settings.first_timepoint + NameUtils.countValidFilesInDirectory(Settings.input_directory, Settings.base_timepoint_name, Settings.filename_syntax) -1;		Settings.base_timepoint_name = NameUtils.findBaseFileName(Settings.input_filename);		ted = new ThreshEstDlog(Settings.image_window, true, cancelled);		ted.setVisible(true);		 		if (cancelled.getValue())			throw new CancelledException();			 		return;			}// end of getUserProcessingInfo()			//********************************************************************************	//*		G E T  E S T I M A T O R	//********************************************************************************	private void getEstimator() throws Exception	{			if (!(Settings.image_width > 0) || !(Settings.image_height > 0))			throw new Exception("Image width or height is zero or less!");				//***** Get our estimator		estimator = new wvFindThreshold("TestThreshold.bin",										CompressionSettings.focalplanes_per_block,										CompressionSettings.timepoints_per_block,										Settings.image_width,										Settings.image_height,										(float)CompressionSettings.p,										wvGraylevels.GRAY8BIT);															return;			}// end of getEstimator()		//********************************************************************************	//*		C A L C U L A T E  T H R E S H O L D	//********************************************************************************	private void calculateThreshold() throws Exception	{				//***** Inform the user this may take some time		Settings.image_window.displayMessage("Calculating threshold.  Please wait...");				//***** Start the calculations		estimator.findBoundsThreaded(wvFindThreshold.START_THRESHOLD, Settings.desired_compression_ratio);																	return;			}// end of calculateThreshold()			//********************************************************************************	//*		D O  U P D A T I N G	//********************************************************************************	protected void doUpdating()	{		long	next_update = 0;				keep_updating = true;		try		{					while (keep_updating)			{				//***** Do GUI updating				Settings.status_panel.handleElapsedTime();				Settings.status_panel.handleTimeRemaining("??:??:??");				next_update = System.currentTimeMillis() + 499;								//***** Do threshold updating, if necessary				if (waiting_for_threshold)					doThresholdEstimationUpdating();																						try				{					update_thread.sleep(499);				}				catch (InterruptedException ie){}							}// while keep_updating		}		catch (Exception e) {}				return;			}// end of doUpdating	//********************************************************************************	//*		D O  T H R E S H O L D  E S T I M A T I O N  U P D A T I N G	//********************************************************************************	protected void doThresholdEstimationUpdating()	{		wvThresholdAndValue		threshold_value = null;		String					message_string = null;		//***** Look for errors or problems		if (estimator.errorOccurred() || estimator.maxItersExceeded())		{			waiting_for_threshold = false;							Settings.image_window.displayMessage("Error.  Unable to calculate threshold.");			return;			}// if an error occurred				//****** Look for messages		message_string = estimator.getMessage();		if (message_string != null)			Settings.image_window.displayMessage(message_string);				//***** Look for the latest "best guess" on the compression					threshold_value = estimator.getBestPoint();				if (last_value == null)			last_value = threshold_value;								//***** Display the value if it has changed since the last time we checked		if (threshold_value.m_threshold != last_value.m_threshold)		{			last_value = threshold_value;			displayThresholdAndValue(threshold_value);		}							//***** If we're done, display the results and get out		if (estimator.doneCalculating())		{			CompressionSettings.threshold = threshold_value.m_threshold;			waiting_for_threshold = false;			Settings.image_window.displayMessage("Final Threshold Results:");			displayThresholdAndValue(threshold_value);		}// if we're done calculating the threshold				return;			}// end of doThresholdEstimationUpdating()	//********************************************************************************	//*		D I S P L A Y  T H R E S H O L D  A N D  V A L U E	//********************************************************************************	protected void displayThresholdAndValue(wvThresholdAndValue threshold_value)	{				try		{			Settings.image_window.displayMessage("Threshold Value: " + threshold_value.m_threshold);			Settings.image_window.displayMessage("Actual Compression Ratio: " + threshold_value.m_value);					}		catch (Exception e)		{			Settings.image_window.displayMessage("Cannot calculate compression ratio and threshold.");		}				return;		}// end of displayThresholdAndValue()	//********************************************************************************	//*		C H E C K  F O R  A B O R T	//*		Last modified 7/1/02	//********************************************************************************	protected void checkForAbort() throws AbortedException	{		if (Settings.abort)			estimator.abort();					super.checkForAbort();				return;			}// end of checkForAbort()			//********************************************************************************	//*		H A N D L E  C A N C E L L E D	//*		Last updated 5/30/02	//********************************************************************************	protected void handleCancelled()	{		Settings.resetSettings();		resetClassVariables();		Settings.image_window.displayMessage("Threshold estimation was cancelled.");				return;			}// end of handleCancelled()	//********************************************************************************	//*		H A N D L E  A B O R T E D	//*		Last updated 6/6/02	//********************************************************************************	protected void handleAborted()	{		Settings.resetSettings();		resetClassVariables();		Settings.image_window.displayMessage("Threshold estimation was aborted.");				return;			}// end of handleAborted()	//********************************************************************************	//*		H A N D L E  O U T  O F  M E M O R Y	//*		Last updated 6/6/02	//********************************************************************************	protected void handleOutOfMemory()	{		Settings.image_window.displayMessage("Out of memory error generated.");		Settings.image_window.displayMessage("Threshold estimation failed.");		keep_updating = false;		Settings.resetSettings();				return;			}// end of handleOutOfMemory()	//********************************************************************************	//*		R E S E T  C L A S S  V A R I A B L E S	//********************************************************************************	protected void resetClassVariables()	{		super.resetClassVariables();		estimator = null;		keep_updating = false;						return;			}// end of resetClassVariables()	//********************************************************************************	//*		U P D A T E  I N F O  P A N E L	//********************************************************************************		private void updateInfoPanel(int cur_timepoint, int cur_focalplane)	{		try		{			Settings.status_panel.handleCurImage(this.images_processed);			Settings.status_panel.handleTotalImages(CompressionSettings.timepoints_per_block * CompressionSettings.focalplanes_per_block);			Settings.status_panel.handleCurTimepoint(cur_timepoint);			Settings.status_panel.handleCurFocalplane(cur_focalplane);			Settings.status_panel.handleElapsedTime();			Settings.status_panel.handleTimeRemaining("??:??:??");			Settings.status_panel.handleFilename(Settings.input_filename);			}		catch (Exception e){}				return;			}// end of updateInfoPanel()	}// end of class ThresholdEstimator